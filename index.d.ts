//
// Auto-generated by dts-generator (https://github.com/enlight/dts-generator/)
//


declare module 'debug-workbench-core-components/lib/debug-engine' {
	import { Disposable } from 'event-kit';
	export interface IDebugConfigElementBehavior {
	    onOpened(callback: () => void): Disposable;
	    onClosed(callback: (closingReason: PolymerElements.IClosingReason) => void): Disposable;
	    open(): void;
	    close(): void;
	    destroy(): void;
	}
	export interface IDebugConfigElement extends IDebugConfigElementBehavior, HTMLElement {
	}
	export interface IDebugConfig {
	    name: string;
	    engine: string;
	}
	export interface IDebugSession {
	    end(): Promise<void>;
	}
	export interface IDebugEngine {
	    name: string;
	    createConfig(configName: string): IDebugConfig;
	    cloneConfig(config: IDebugConfig): IDebugConfig;
	    createConfigElement(config: IDebugConfig): Promise<IDebugConfigElement>;
	    startDebugSession(config: IDebugConfig): Promise<IDebugSession>;
	}

}

declare module 'debug-workbench-core-components/lib/element-factory' {
	export interface IElementFactory {
	    setElementConstructor(tagName: string, elementConstructor: Function): void;
	    createElement(tagName: string, ...args: any[]): Promise<HTMLElement>;
	    /**
	     * Create an element from the debug-workbench namespace.
	     * @param tagName Name of the element to create, without the 'debug-workbench-' namespace prefix.
	     *                e.g. to create an element that was registered under the name
	     *                'debug-workbench-my-element' specify 'my-element'.
	     * @param args Arguments to pass through to the element constructor.
	     */
	    createCoreElement(tagName: string, ...args: any[]): Promise<HTMLElement>;
	}

}

declare module 'debug-workbench-core-components/lib/debug-engine-provider' {
	import { IDebugEngine } from 'debug-workbench-core-components/lib/debug-engine';
	export interface IDebugEngineProvider {
	    engineName: string;
	    createEngine(): IDebugEngine;
	}
	export function register(provider: IDebugEngineProvider): void;
	export function unregisterAll(): void;
	export function getEngine(engineName: string): IDebugEngine;

}

declare module 'debug-workbench-core-components/lib/gdb-mi-debug-engine' {
	import { IDebugEngine } from 'debug-workbench-core-components/lib/debug-engine';
	import { IDebugEngineProvider } from 'debug-workbench-core-components/lib/debug-engine-provider';
	export class GdbMiDebugEngineProvider implements IDebugEngineProvider {
	    engineName: string;
	    createEngine(): IDebugEngine;
	}

}

declare module 'debug-workbench-core-components/lib/debug-config-manager' {
	import { IDebugConfig } from 'debug-workbench-core-components/lib/debug-engine';
	import { Disposable } from 'event-kit';
	export interface IDebugConfigRenameInfo {
	    newName: string;
	    oldName: string;
	}
	/**
	 * Manages access to debug configs.
	 *
	 * Debug configs are saved to a single file stored at the path passed to the constructor.
	 * To modify a config, clone an existing one, modify the clone, then save the clone (this will
	 * replace the existing config).
	 */
	export default class DebugConfigManager {
	    private configPath;
	    /** Original unmodified configs, should always be kept in sync with what's actually on disk. */
	    private debugConfigs;
	    /** Copies of original configs, these contain changes that may be saved to disk or discared. */
	    private pendingChanges;
	    private emitter;
	    constructor(configPath: string);
	    /** Add a function that should be called after a new debug config is saved. */
	    onDidAddConfig(callback: (addedConfig: IDebugConfig) => void): Disposable;
	    /** Add a function that should be called after a debug config is permanently removed. */
	    onDidRemoveConfig(callback: (removedConfig: IDebugConfig) => void): Disposable;
	    /** Add a function that should be called after a name change is saved. */
	    onDidRenameConfig(callback: {
	        ({newName, oldName}: IDebugConfigRenameInfo): void;
	    }): Disposable;
	    /**
	     * Get a saved debug config with the given name.
	     *
	     * The returned config should be considered read-only, to modify a config call [[modify]].
	     * @return A matching IDebugConfig, or null.
	     */
	    get(configName: string): IDebugConfig;
	    /**
	     * Get all saved debug configs.
	     * The returned configs should be considered read-only, to modify a config call [[modify]].
	     */
	    getAll(): IDebugConfig[];
	    /**
	     * Make a copy of a config for modification.
	     *
	     * Once the returned config has been modified the changes can be saved to disk
	     * by calling [[save]], or discarded by calling [[discardChanges]].
	     * @return A copy of the given config.
	     */
	    modify(debugConfig: IDebugConfig): IDebugConfig;
	    /**
	     * Discard any modifications made to a config.
	     *
	     * @param debugConfig An unsaved config returned by [[modify]].
	     */
	    discardChanges(debugConfig: IDebugConfig): void;
	    /**
	     * Save a new or modified config.
	     *
	     * @param debugConfig A newly created config or one returned by [[modify]].
	     * @return A promise that will be resolved once the change has been written to disk.
	     */
	    save(debugConfig: IDebugConfig): Promise<void>;
	    /**
	     * Permanently remove a config from memory and disk.
	     *
	     * @return A promise that will be resolved once the change has been written to disk.
	     */
	    remove(debugConfig: IDebugConfig): Promise<void>;
	    /**
	     * Load all configs from disk.
	     *
	     * @return A promise that will be resolved once all configs have been loaded.
	     */
	    load(): Promise<void>;
	    private checkConfigFileExists();
	    private readFromDisk();
	    private writeToDisk(configs);
	}

}

declare module 'debug-workbench-core-components/lib/debug-workbench' {
	import { IElementFactory } from 'debug-workbench-core-components/lib/element-factory';
	import { IDebugEngine } from 'debug-workbench-core-components/lib/debug-engine';
	import DebugConfigManager from 'debug-workbench-core-components/lib/debug-config-manager';
	export var debugConfigs: DebugConfigManager;
	export interface IActivationConfig {
	    openDebugConfig: (configName: string) => void;
	    elementFactory: IElementFactory;
	    debugConfigManager: DebugConfigManager;
	}
	export function activate(config: IActivationConfig): void;
	export function deactivate(): void;
	export function openDebugConfig(configName?: string): void;
	export function getDebugEngine(engineName: string): IDebugEngine;
	export function createElement(tagName: string, ...args: any[]): Promise<HTMLElement>;
	export function createCoreElement(tagName: string, ...args: any[]): Promise<HTMLElement>;
	export function setElementConstructor(tagName: string, elementConstructor: Function): void;

}

declare module 'debug-workbench-core-components/debug-configuration/debug-configuration' {
	import { IDebugConfigElementBehavior, IDebugConfig } from 'debug-workbench-core-components/lib/debug-engine';
	import { Disposable } from 'event-kit';
	/**
	 * Base behavior of the DebugConfigurationElement.
	 */
	export default class DebugConfigurationElement implements IDebugConfigElementBehavior {
	    private debugConfig;
	    private emitter;
	    static create(debugConfig: IDebugConfig): Promise<IDebugConfigurationElement>;
	    created(): void;
	    destroy(): void;
	    /** Called after ready() with arguments passed to the element constructor function. */
	    factoryImpl(debugConfig: IDebugConfig): void;
	    private onIronOverlayOpened(e);
	    private onIronOverlayClosed(e);
	    /** Add a function to be called when the dialog is opened. */
	    onOpened(callback: () => void): Disposable;
	    /** Add a function to be called when the dialog is closed. */
	    onClosed(callback: (closingReason: PolymerElements.IClosingReason) => void): Disposable;
	    open(): void;
	    close(): void;
	}
	export interface IDebugConfigurationElement extends DebugConfigurationElement, HTMLElement {
	}
	export function register(): typeof DebugConfigurationElement;

}

declare module 'debug-workbench-core-components/lib/disposable-dom-event-listener' {
	import { Disposable } from 'event-kit';
	/**
	 * Add an event listener to a DOM node.
	 *
	 * @return An object that upon being disposed will remove the event listener from the node it was
	 *         originally added to.
	 */
	export default function add(node: HTMLElement, eventName: string, callback: EventListener): Disposable;

}

declare module 'debug-workbench-core-components/debug-toolbar/debug-toolbar' {
	import { Disposable } from 'event-kit';
	export default class DebugToolbarElement {
	    private subscriptions;
	    private debugSession;
	    private debugConfigs;
	    static create(): Promise<IDebugToolbarElement>;
	    /** Add a listener to be called when the Start button is pressed. */
	    onStartButtonPressed(callback: EventListener): Disposable;
	    /** Add a listener to be called when the Stop button is pressed. */
	    onStopButtonPressed(callback: EventListener): Disposable;
	    /** Add a listener to be called when the Settings button is pressed. */
	    onSettingsButtonPressed(callback: EventListener): Disposable;
	    created(): void;
	    ready(): void;
	    destroy(): void;
	    private startDebugging();
	    private stopDebugging();
	    private openSettings();
	    private willSelectDebugConfig(e);
	    private didSelectDebugConfig();
	}
	export interface IDebugToolbarElement extends DebugToolbarElement, HTMLElement {
	}
	export function register(): typeof DebugToolbarElement;

}

declare module 'debug-workbench-core-components/file-input/file-input' {
	export class FileInputElement {
	    /** The returned object will only be valid after the element has been upgraded to a custom element. */
	    base: polymer.Base;
	    inputLabel: string;
	    filePath: string;
	    openBrowseDialog(): void;
	}
	export function register(): typeof FileInputElement;

}

declare module 'debug-workbench-core-components/new-debug-config-dialog/new-debug-config-dialog' {
	import { Disposable } from 'event-kit';
	import { IDebugConfig } from 'debug-workbench-core-components/lib/debug-engine';
	/**
	 * A simple dialog that lets the user enter the name for a new debug config and select
	 * the debug engine the new config will be used with.
	 */
	export default class NewDebugConfigDialogElement {
	    private emitter;
	    static create(): Promise<INewDebugConfigDialogElement>;
	    created(): void;
	    destroy(): void;
	    private onIronOverlayOpened(e);
	    private onIronOverlayClosed(e);
	    /** Add a function to be called when the dialog is opened. */
	    onOpened(callback: () => void): Disposable;
	    /** Add a function to be called when the dialog is closed. */
	    onClosed(callback: (debugConfig: IDebugConfig) => void): Disposable;
	    open(): void;
	    close(): void;
	}
	export interface INewDebugConfigDialogElement extends NewDebugConfigDialogElement, HTMLElement {
	}
	export function register(): typeof NewDebugConfigDialogElement;

}

declare module 'debug-workbench-core-components/register-element/register-element' {
	/** Custom element that loads and registers a custom element from a CommonJS module. */
	export class RegisterElementElement {
	    /** The returned object will only be valid after the element has been upgraded to a custom element. */
	    base: polymer.Base;
	    path: string;
	    ready(): void;
	}
	export function register(): typeof RegisterElementElement;

}
